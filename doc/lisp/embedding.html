

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Embedding the Interpreter &mdash; libstephen 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="libstephen 0.1 documentation" href="../index.html"/>
        <link rel="up" title="Lisp Implementation Documentation" href="index.html"/>
        <link rel="next" title="Type System" href="types.html"/>
        <link rel="prev" title="Intro to Reference Counting" href="refcount.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> libstephen
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Libstephen Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">Libstephen API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Lisp Implementation Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="refcount.html">Intro to Reference Counting</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Embedding the Interpreter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-repl">The REPL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-builtins">Writing Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basics-of-lisp-types">Basics of Lisp Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-builtins-to-the-scope">Adding Builtins to the Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Type System</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">libstephen</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Lisp Implementation Documentation</a> &raquo;</li>
      
    <li>Embedding the Interpreter</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/lisp/embedding.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="embedding-the-interpreter">
<h1>Embedding the Interpreter<a class="headerlink" href="#embedding-the-interpreter" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-repl">
<h2>The REPL<a class="headerlink" href="#the-repl" title="Permalink to this headline">¶</a></h2>
<p>With a working understanding of the basics of the reference counting system, the
basic read-eval-print loop for the interpreter is simple. Taking it in steps:</p>
<ol class="arabic simple">
<li>Read a line of input.</li>
<li>Parse the input. Parsed code is simply a <code class="docutils literal"><span class="pre">lisp_value</span></code> like any other
language object, and so the REPL now owns a reference to the input.</li>
<li>Free the line of input.</li>
<li>Evaluate the input. Similar to the above, the REPL now owns references to the
result.</li>
<li>Decref the code, since it is no longer needed.</li>
<li>Print the output, and a trailing newline.</li>
<li>Decref the output, since it is no longer needed.</li>
</ol>
<p>One major issue is overlooked in these steps: scope. The scope is simply a
mapping of names (i.e. <code class="docutils literal"><span class="pre">lisp_symbol</span></code> objects) to values (any <code class="docutils literal"><span class="pre">lisp_value</span></code>).
A scope is required to evaluate any code. The scope contains most of the
critical builtin functions for lisp, such as <code class="docutils literal"><span class="pre">car</span></code>, <code class="docutils literal"><span class="pre">cdr</span></code>, <code class="docutils literal"><span class="pre">cons</span></code>, etc.
The scope may also be modified by the builtin function <code class="docutils literal"><span class="pre">define</span></code>, so that code
can bind a name to a value it creates (such as a function).</p>
<p>Before an interpreter can evaluate any code, it must instantiate a scope and
populate it with the basic built-in functions for lisp. Once the interpreter has
exited, we can decref it, which should free every key and value that was stored
in the scope.</p>
<p>With the scope in mind, here is some basic code that demonstrates embedding a
simple lisp interpreter, without any custom functions. It uses the <code class="docutils literal"><span class="pre">editline</span></code>
implementation of the <code class="docutils literal"><span class="pre">readline</span></code> library for reading input (and allowing line
editing).</p>
<div class="code C highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;editline/readline.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;libstephen/lisp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">Argo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">lisp_scope</span> <span class="o">*</span><span class="n">scope</span> <span class="o">=</span> <span class="p">(</span><span class="n">lisp_scope</span><span class="o">*</span><span class="p">)</span><span class="n">type_scope</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">();</span>
  <span class="n">lisp_scope_populate_builtins</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>

  <span class="c1">// Add your own builtins here?</span>

  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">readline</span><span class="p">(</span><span class="s">&quot;&gt; &quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lisp_value</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">lisp_parse</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">add_history</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="c1">// for editline history only</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">lisp_value</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">lisp_eval</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">lisp_decref</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">lisp_print</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">lisp_decref</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">lisp_decref</span><span class="p">((</span><span class="n">lisp_value</span><span class="o">*</span><span class="p">)</span><span class="n">scope</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-builtins">
<h2>Writing Builtins<a class="headerlink" href="#writing-builtins" title="Permalink to this headline">¶</a></h2>
<p>Typically, an embedded interpreter will not be of much use to your application
unless you can also add functions to the global scope. The most straightforward
way to add your own functionality to the interpreter is by writing a &#8220;builtin&#8221;.
This is a C function which may be called by lisp code. Builtins must have the
following signature:</p>
<div class="code C highlight-c"><div class="highlight"><pre><span></span><span class="n">lisp_value</span> <span class="o">*</span><span class="nf">lisp_builtin_somename</span><span class="p">(</span><span class="n">lisp_scope</span> <span class="o">*</span><span class="n">scope</span><span class="p">,</span> <span class="n">lisp_value</span> <span class="o">*</span><span class="n">arglist</span><span class="p">);</span>
</pre></div>
</div>
<p>The scope argument contains the current binding of names to values, and the
arglist is a list of arguments to your function, which <strong>have not been
evaluated</strong>. These arguments are essentially code objects. You&#8217;ll almost always
want to evaluate them all before continuing with the logic of the function. You
can do this individually with the <code class="docutils literal"><span class="pre">lisp_eval()</span></code> function, or just evaluate the
whole list of arguments with the <code class="docutils literal"><span class="pre">lisp_eval_list()</span></code> function.</p>
<p>The one exception to evaluating all of your arguments is if you&#8217;re defining some
sort of syntactic construct. For instance, if you were to write a builtin
function for an if-statement, you would evaluate the expression, and then
conditionally evaluate one of the two other expressions (but not both) depending
on the value of the expression.</p>
<p>Finally, when you have your argument list, you could verify them all manually,
but this process gets annoying very fast. To simplify this process, there is
<code class="docutils literal"><span class="pre">lisp_get_args()</span></code>, a function which takes a list of (evaluated or unevaluated)
arguments and a format string, along with a list of pointers to result
variables. Similar to <code class="docutils literal"><span class="pre">Scan()</span></code>, it reads a type code from the format string
and attempts to take the next object off of the list, verify the type, and
assign it to the current variable in the list. The current format string
characters are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">d</span></code>: for integer</li>
<li><code class="docutils literal"><span class="pre">l</span></code>: for list</li>
<li><code class="docutils literal"><span class="pre">s</span></code>: for symbol</li>
<li><code class="docutils literal"><span class="pre">S</span></code>: for string</li>
<li><code class="docutils literal"><span class="pre">o</span></code>: for scope</li>
<li><code class="docutils literal"><span class="pre">e</span></code>: for error</li>
<li><code class="docutils literal"><span class="pre">b</span></code>: for builtin</li>
<li><code class="docutils literal"><span class="pre">t</span></code>: for type</li>
<li><code class="docutils literal"><span class="pre">*</span></code>: for anything</li>
</ul>
<p>So, a format string for the plus function would be <code class="docutils literal"><span class="pre">&quot;dd&quot;</span></code>, and the format
string for the <code class="docutils literal"><span class="pre">cons</span></code> function is <code class="docutils literal"><span class="pre">&quot;**&quot;</span></code>, because any two things may be put
together in an s-expression. If nothing else, the <code class="docutils literal"><span class="pre">lisp_get_args()</span></code> function
can help you verify the number of arguments, if not their types. When it fails,
it returns false, which you should typically handle by returning an error
(<code class="docutils literal"><span class="pre">lisp_error_new()</span></code>). You should be sure to decref anything you have allocated
as you parsed your arguments (such as the return value from
<code class="docutils literal"><span class="pre">lisp_eval_list()</span></code>). Even when an error has occurred!</p>
<p>At this point, your function is free to do whatever logic you&#8217;d like. Keep in
mind that the return value of <code class="docutils literal"><span class="pre">lisp_eval_list()</span></code> must be decref&#8217;d when you&#8217;re
done with it, and also that your return values must be new references.</p>
</div>
<div class="section" id="basics-of-lisp-types">
<h2>Basics of Lisp Types<a class="headerlink" href="#basics-of-lisp-types" title="Permalink to this headline">¶</a></h2>
<p>In order to write any interesting functions, you need a basic idea of how types
are represented and how you can get argument values out of the <code class="docutils literal"><span class="pre">lisp_value</span></code>
objects. This is not a description of the type system (a future page in this
section will cover that), just a list of available types and their values.</p>
<p>The current types (that you are likely to use) are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">lisp_list</span></code>: contains a <code class="docutils literal"><span class="pre">left</span></code> and a <code class="docutils literal"><span class="pre">right</span></code> pointer.<ul>
<li><code class="docutils literal"><span class="pre">left</span></code> is usually a value of the linked list, and <code class="docutils literal"><span class="pre">right</span></code> is usually the
next list in the linked list. However this isn&#8217;t necessarily the case,
because this object really represents an s-expression, and the right value
of an s-expression doesn&#8217;t have to be another s-expression.</li>
<li>The empty list is a special instance of <code class="docutils literal"><span class="pre">lisp_list</span></code>. You can get a new
reference to it with <code class="docutils literal"><span class="pre">lisp_nil_new()</span></code> and you can check if an object is
nil by calling <code class="docutils literal"><span class="pre">lisp_nil_p()</span></code>.</li>
<li>You can find the length of a list by using <code class="docutils literal"><span class="pre">lisp_list_length()</span></code>.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">lisp_symbol</span></code>: type that represents names. Contains <code class="docutils literal"><span class="pre">sym</span></code>, which is a
<code class="docutils literal"><span class="pre">char*</span></code>.</li>
<li><code class="docutils literal"><span class="pre">lisp_error</span></code>: similar to a symbol in implementation, but represents an
error. Has the attribute <code class="docutils literal"><span class="pre">message</span></code> which contains the error message. Create
a new one with <code class="docutils literal"><span class="pre">lisp_error_new(message)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">lisp_integer</span></code>: contains attribute <code class="docutils literal"><span class="pre">x</span></code>, an integer. Yes, it&#8217;s allocated on
the heap.  Get over it.</li>
<li><code class="docutils literal"><span class="pre">lisp_string</span></code>: another thing similar to a symbol in implementation, but this
time it represents a language string literal. The <code class="docutils literal"><span class="pre">s</span></code> attribute holds the
string value.</li>
</ul>
<p>There are also types for builtin functions, lambdas, scopes, and even a type for
types!  But you probably won&#8217;t use them in your average code.</p>
<p>The following functions can be called on any lisp type (they may raise errors if
not applicable):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">lisp_print(FILE</span> <span class="pre">*f,</span> <span class="pre">lisp_value</span> <span class="pre">*v)</span></code></li>
<li><code class="docutils literal"><span class="pre">lisp_eval(lisp_scope</span> <span class="pre">*s,</span> <span class="pre">lisp_value</span> <span class="pre">*v)</span></code></li>
<li><code class="docutils literal"><span class="pre">lisp_call(lisp_scope</span> <span class="pre">*s,</span> <span class="pre">lisp_value</span> <span class="pre">*callable,</span> <span class="pre">lisp_value</span> <span class="pre">*arguments)</span></code>
- invokes <code class="docutils literal"><span class="pre">callable</span></code> on <code class="docutils literal"><span class="pre">arguments</span></code> in scope <code class="docutils literal"><span class="pre">s</span></code>.</li>
<li>Of course, <code class="docutils literal"><span class="pre">lisp_incref</span></code> and <code class="docutils literal"><span class="pre">lisp_decref</span></code>. There is also <code class="docutils literal"><span class="pre">lisp_free</span></code>,
but that shouldn&#8217;t ever be used.</li>
</ul>
</div>
<div class="section" id="adding-builtins-to-the-scope">
<h2>Adding Builtins to the Scope<a class="headerlink" href="#adding-builtins-to-the-scope" title="Permalink to this headline">¶</a></h2>
<p>Once you have written your functions, you must finally add them to the
interpreter&#8217;s global scope. Anything can be added to a scope with
<code class="docutils literal"><span class="pre">lisp_scope_bind()</span></code>., but the name needs to be a <code class="docutils literal"><span class="pre">lisp_symbol</span></code> instance and
the value needs to be a <code class="docutils literal"><span class="pre">lisp_value</span></code>. To save you the trouble of creating
those objects, you can simply use <code class="docutils literal"><span class="pre">lisp_scope_add_builtin()</span></code>, which takes a
scope, a string name, and a function pointer.</p>
<p>Here is a code example that puts all of this together, based on the REPL given
above.</p>
<div class="code C highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;editline/readline.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;libstephen/lisp.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="n">lisp_value</span> <span class="o">*</span><span class="nf">say_hello</span><span class="p">(</span><span class="n">lisp_scope</span> <span class="o">*</span><span class="n">scope</span><span class="p">,</span> <span class="n">lisp_value</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Evaluate our arguments.</span>
  <span class="n">lisp_value</span> <span class="o">*</span><span class="n">arglist</span> <span class="o">=</span> <span class="n">lisp_eval_list</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="c1">// Check our number and type of arguments.</span>
  <span class="n">lisp_string</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lisp_get_args</span><span class="p">((</span><span class="n">lisp_list</span><span class="o">*</span><span class="p">)</span><span class="n">arglist</span><span class="p">,</span> <span class="s">&quot;S&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Don&#39;t forget to decref on error.</span>
    <span class="n">lisp_decref</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lisp_value</span><span class="o">*</span><span class="p">)</span><span class="n">lisp_error_new</span><span class="p">(</span><span class="s">&quot;error: expected a string!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Perform our logic.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>

  <span class="c1">// Decref the evaluated arguments, which we owned.</span>
  <span class="n">lisp_decref</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>

  <span class="c1">// we have to return something...</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">lisp_value</span><span class="o">*</span><span class="p">)</span> <span class="n">lisp_nil_new</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">lisp_scope</span> <span class="o">*</span><span class="n">scope</span> <span class="o">=</span> <span class="p">(</span><span class="n">lisp_scope</span><span class="o">*</span><span class="p">)</span><span class="n">type_scope</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">();</span>
  <span class="n">lisp_scope_populate_builtins</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>

  <span class="n">lisp_scope_add_builtin</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">say_hello</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">readline</span><span class="p">(</span><span class="s">&quot;&gt; &quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lisp_value</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">lisp_parse</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">add_history</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">lisp_value</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">lisp_eval</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">lisp_decref</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">lisp_print</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">lisp_decref</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">lisp_decref</span><span class="p">((</span><span class="n">lisp_value</span><span class="o">*</span><span class="p">)</span><span class="n">scope</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example session using the builtin:</p>
<div class="code highlight-c"><div class="highlight"><pre><span></span>&gt; (hello &quot;Stephen&quot;)
Hello, Stephen!
()
&gt; (hello 1)
error: error: expected a string!
&gt; (hello &#39;Stephen)
error: error: expected a string!
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="types.html" class="btn btn-neutral float-right" title="Type System" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="refcount.html" class="btn btn-neutral" title="Intro to Reference Counting" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2016, Stephen Brennan.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>