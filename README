################################################################################
#################################### README ####################################
################################################################################

Library: libstephen

Description: a library (currently static, but I may compile as dynamic in the
near future) containing basic generic data structures, and also some headers
that are useful for general development.  Additionally, it contains a unit
testing framework that allows for expecting errors, and memory leak detection.

############################### DATA STRUCTURES ################################

All my data structures are based on the single basic data type DATA.  It is an 8
byte union that can contain an integer, a double, or a pointer.  

The library attempts to use interface based programming.  That is, the list is
an interface implemented by the linked list and the array list.  To achieve
this, I use stack-based structs that contain void pointers and function
pointers.  A function call in this system looks something like this:

	   structure.function(&structure /* , ... args ... */);

Each implementation, however, should be usable without the interface struct
form.  The reason for this is that the struct form contains tons of function
pointers, and it's really grossly inefficient.  So each implementation I create
has an interface all to itself.  It usually implements the exact same functions
as the interface.  But, instead of taking a struct pointer as their first
argument, they take a pointer to the actual data structure.  Then, for every
interface function, an "adapter" function is created.  Struct versions are
loaded with pointers to these functions.  The adapter functions are not publicly
accessible.

So, first I'll give an interface, followed by its implementations.

##### LIST (libstephen.h)

Holds sequential data.  Allows for deletion and insertion into arbitrary
locations in the list.

Functions:

append() - Add a data element to the end of the list.
prepend() - Add a data element to the end of the list.
get() - Get the data element at the specified index.
set() - Set the data element at the specified index.
remove() - Remove the element at the specified index.
insert() - Insert an element at the specified index.
delete() - Delete the list.
// get_iter() - Return an iterator set to the first element. *

push_back() - Push to back (append()).
pop_back() - Pop from back.
peek_back() - Peek at back.
push_front() - Push to front (prepend()).
pop_front() - Pop from front.
peek_front() - Peek at front.

* The get_iter() and the iterator functions are not yet implemented on all list
  implementations

##### LINKED_LIST (linkedlist.c)

The linked list is an implementation of the list interface.  It works by storing
each element in dynamically allocated memory with pointers to the next and
previous element.  Access time suffers, but insertion and removal require no
shifting.  It has all the functions required by the list interface.  The
prefixes for normal linked list functions is "ll_".  Additional to the interface
are the following functions:

LINKED_LIST *ll_create(DATA d);
LINKED_LIST *ll_create_empty();
LIST *ll_create_list(DATA d);
LIST *ll_create_empty_list();
LIST ll_cast_to_list(LINKED_LIST *list);

These functions are critical because interfaces don't provide means for
instantiation.  Additionally, these functions, prefixed by "ll_iter_", are the
iterator functions.  They are completely usable as is, and they are to be used
for the upcoming interface for LIST iterators.

next() - Advance and return.
prev() - Move back and return.
curr() - Return current data.
has_next()
has_prev()
valid() - Check if the iterator points to anything useful.

##### ARRAY_LIST (arraylist.c)

The array list is an implementation of the list interface It works by storing
each element in a single contiguous block of memory.  Access is constant time
through indexing, but insertion and deletion can suffer in runtime due to
occasional reallocations of memory.  It contains all required list interface
functions.  Its function prefix is "al_".  It additionally has the same create
and cast functions that the linked list has.  It does not have any iterator
capability yet.

##### Chunked Array List

The chunked array list is an array list with my own personal twist to it.
Instead of storing all data in one contiguous block of memory, we store the data
in segments of memory.  When we must expand, we simply allocate an additional
chunk of memory and use that.  Some mechanism of storage will be used to store
the initial memory address of each block of memory.  Access will still be
constant time, but there will no longer be the same overhead for expansion or
memory allocation.